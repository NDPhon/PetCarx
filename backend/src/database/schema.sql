-- ============================================
-- 0. CREATE DATABASE (chỉ chạy được nếu bạn có quyền tạo DB)
-- Nếu trên cloud (Neon, Supabase), thường bạn KHÔNG cần đoạn này
-- ============================================
-- CREATE DATABASE petcarex;
-- \c petcarex;

-- Với hầu hết cloud Postgres, bạn chỉ cần chắc chắn đang kết nối vào DB đúng tên.

-- ============================================
-- 1. MASTER TABLES
-- ============================================

-- 1.1 Branch
CREATE TABLE branch (
    branch_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name        VARCHAR(100)      NOT NULL,
    address     VARCHAR(200)      NOT NULL,
    phone       VARCHAR(20)       NOT NULL UNIQUE,
    open_time   TIME(0)           NOT NULL,
    close_time  TIME(0)           NOT NULL,
    is_active   BOOLEAN           NOT NULL DEFAULT TRUE,
    CONSTRAINT ck_branch_time CHECK (open_time < close_time)
);

-- 1.2 Warehouse
CREATE TABLE warehouse (
    warehouse_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    branch_id    INTEGER      NOT NULL REFERENCES branch(branch_id),
    name         VARCHAR(100) NOT NULL,
    phone        VARCHAR(20),
    address      VARCHAR(200) NOT NULL
);

-- 1.3 Service
CREATE TABLE service (
    service_id    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    service_name  VARCHAR(100)     NOT NULL,
    service_type  VARCHAR(30)      NOT NULL,
    base_price    NUMERIC(18,2)    NOT NULL DEFAULT 0,
    description   VARCHAR(500),
    is_active     BOOLEAN          NOT NULL DEFAULT TRUE,
    CONSTRAINT ck_service_type CHECK (service_type IN ('Exam','Vaccination','Other')),
    CONSTRAINT ck_service_price CHECK (base_price >= 0)
);

-- 1.4 Product
select * from 
CREATE TABLE product (
    product_id    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_name  VARCHAR(100)   NOT NULL,
    product_type  VARCHAR(30)    NOT NULL,
    unit          VARCHAR(20)    NOT NULL,
    price         NUMERIC(18,2)  NOT NULL,
    expiry_date   DATE,
    description   VARCHAR(500),
    is_active     BOOLEAN        NOT NULL DEFAULT TRUE,
    CONSTRAINT ck_product_price CHECK (price >= 0)
);

-- 1.5 MembershipTier
CREATE TABLE membership_tier (
    tier_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier_name         VARCHAR(50)     NOT NULL UNIQUE,
    qualify_spend_year NUMERIC(18,2)  NOT NULL,
    retain_spend_year  NUMERIC(18,2)  NOT NULL,
    description       VARCHAR(200),
    CONSTRAINT ck_membership_spend CHECK (qualify_spend_year >= 0 AND retain_spend_year >= 0)
);

-- 1.6 Promotion
CREATE TABLE promotion (
    promotion_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    promotion_name VARCHAR(100)    NOT NULL,
    promotion_type VARCHAR(20)     NOT NULL,  -- 'Percent','FixedAmount',...
    value          NUMERIC(18,2)   NOT NULL,
    start_date     DATE            NOT NULL,
    end_date       DATE            NOT NULL,
    conditions     VARCHAR(500),
    is_active      BOOLEAN         NOT NULL DEFAULT TRUE,
    CONSTRAINT ck_promotion_value CHECK (value >= 0),
    CONSTRAINT ck_promotion_date  CHECK (end_date > start_date)
);


-- 1.7 BranchService
CREATE TABLE branch_service (
    branch_id      INTEGER       NOT NULL REFERENCES branch(branch_id),
    service_id     INTEGER       NOT NULL REFERENCES service(service_id),
    price_override NUMERIC(18,2),
    is_available   BOOLEAN       NOT NULL DEFAULT TRUE,
    CONSTRAINT pk_branch_service PRIMARY KEY (branch_id, service_id),
    CONSTRAINT ck_branch_service_price CHECK (price_override IS NULL OR price_override >= 0)
);


-- ============================================
-- 2. CORE ENTITIES: CUSTOMER, PET, EMPLOYEE
-- ============================================

-- 2.1 Customer
CREATE TABLE customer (
    customer_id    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    full_name      VARCHAR(100)    NOT NULL,
    gender         CHAR(1),
    date_of_birth  DATE,
    phone          VARCHAR(20)     NOT NULL UNIQUE,
    email          VARCHAR(100)    UNIQUE,
    national_id    VARCHAR(20)     UNIQUE,
    join_date      DATE            NOT NULL DEFAULT CURRENT_DATE,
    total_spending NUMERIC(18,2)   NOT NULL DEFAULT 0,
    tier_id        INTEGER         NOT NULL REFERENCES membership_tier(tier_id),
    loyalty_points INTEGER         NOT NULL DEFAULT 0,
    CONSTRAINT ck_customer_gender CHECK (gender IN ('M','F','O'))
);
-- 2.2 Pet
CREATE TABLE pet (
    pet_id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id   INTEGER       NOT NULL REFERENCES customer(customer_id),
    pet_name      VARCHAR(100)  NOT NULL,
    species       VARCHAR(50)   NOT NULL,
    breed         VARCHAR(100),
    date_of_birth DATE,
    gender        CHAR(1),
    health_status VARCHAR(200),
    CONSTRAINT ck_pet_gender CHECK (gender IN ('M','F','O'))
);

-- 2.3 Employee
CREATE TABLE employee (
    employee_id  INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    branch_id    INTEGER       NOT NULL REFERENCES branch(branch_id),
    full_name    VARCHAR(100)  NOT NULL,
    gender       CHAR(1),
    date_of_birth DATE,
    hire_date    DATE          NOT NULL DEFAULT CURRENT_DATE,
    base_salary  NUMERIC(18,2) DEFAULT 0,
    position     VARCHAR(30)   NOT NULL,
    status       VARCHAR(20)   NOT NULL DEFAULT 'Active',
    CONSTRAINT ck_employee_gender   CHECK (gender IN ('M','F','O')),
    CONSTRAINT ck_employee_position CHECK (position IN ('Doctor','Sales','Receptionist','BranchManager'))
);

-- ============================================
-- 3. INVENTORY & WAREHOUSE TRANSACTIONS
-- ============================================

-- 3.1 Inventory
CREATE TABLE inventory (
    inventory_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    quantity     INTEGER        NOT NULL DEFAULT 0,
    update_date  TIMESTAMP(0)   NOT NULL DEFAULT CURRENT_TIMESTAMP,
    warehouse_id INTEGER        NOT NULL REFERENCES warehouse(warehouse_id),
    product_id   INTEGER        NOT NULL REFERENCES product(product_id),
    CONSTRAINT ck_inventory_quantity CHECK (quantity >= 0)
);

-- 3.2 WarehouseTransaction
CREATE TABLE warehouse_transaction (
    transaction_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    warehouse_id     INTEGER       NOT NULL REFERENCES warehouse(warehouse_id),
    product_id       INTEGER       NOT NULL REFERENCES product(product_id),
    transaction_type VARCHAR(10)   NOT NULL,
    quantity         INTEGER       NOT NULL,
    transaction_date TIMESTAMP(0)  NOT NULL DEFAULT CURRENT_TIMESTAMP,
    note             VARCHAR(500),
    CONSTRAINT ck_warehouse_transaction_type CHECK (transaction_type IN ('IMPORT','EXPORT')),
    CONSTRAINT ck_warehouse_transaction_qty  CHECK (quantity > 0)
);

-- ============================================
-- 4. VACCINATION PACKAGES & HISTORY
-- ============================================

-- 4.1 VaccinationPackage
CREATE TABLE vaccination_package (
    package_id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    package_name    VARCHAR(100)   NOT NULL,
    duration_months INTEGER        NOT NULL,
    discount_rate   NUMERIC(5,2)   NOT NULL,
    description     VARCHAR(500),
    is_active       BOOLEAN        NOT NULL DEFAULT TRUE,
    CONSTRAINT ck_vaccination_package_duration CHECK (duration_months > 0),
    CONSTRAINT ck_vaccination_package_discount CHECK (discount_rate >= 0 AND discount_rate <= 100)
);

-- 4.2 VaccinePackageDetail
CREATE TABLE vaccine_package_detail (
    package_id    INTEGER      NOT NULL REFERENCES vaccination_package(package_id),
    service_id    INTEGER      NOT NULL REFERENCES service(service_id),
    required_dose INTEGER      NOT NULL,
    interval_days INTEGER      NOT NULL,
    CONSTRAINT pk_vaccine_package_detail PRIMARY KEY (package_id, service_id),
    CONSTRAINT ck_vaccine_package_detail_required_dose CHECK (required_dose > 0),
    CONSTRAINT ck_vaccine_package_detail_interval_days CHECK (interval_days >= 0)
);

-- 4.3 PetVaccinationPackage
CREATE TABLE pet_vaccination_package (
    pet_package_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pet_id         INTEGER      NOT NULL REFERENCES pet(pet_id),
    package_id     INTEGER      NOT NULL REFERENCES vaccination_package(package_id),
    start_date     DATE         NOT NULL,
    end_date       DATE,
    status         VARCHAR(20)  NOT NULL  -- 'Active','Completed','Cancelled'
);

-- 4.4 VaccinationHistory
CREATE TABLE vaccination_history (
    vaccination_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pet_id         INTEGER      NOT NULL REFERENCES pet(pet_id),
    service_id     INTEGER      NOT NULL REFERENCES service(service_id),
    injection_date TIMESTAMP(0) NOT NULL,
    next_due_date  TIMESTAMP(0),
    notes          VARCHAR(500)
);

-- ============================================
-- 5. BILLING: INVOICE, DETAIL, PAYMENT, FEEDBACK
-- ============================================

-- 5.1 Invoice
CREATE TABLE invoice (
    invoice_id      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    branch_id       INTEGER       NOT NULL REFERENCES branch(branch_id),
    customer_id     INTEGER       NOT NULL REFERENCES customer(customer_id),
    employee_id     INTEGER       NOT NULL REFERENCES employee(employee_id),
    created_at      TIMESTAMP(0)  NOT NULL DEFAULT CURRENT_TIMESTAMP,
    total_amount    NUMERIC(18,2) NOT NULL DEFAULT 0,
    discount_amount NUMERIC(18,2) NOT NULL DEFAULT 0,
    final_amount    NUMERIC(18,2) NOT NULL DEFAULT 0,
    promotion_id    INTEGER       REFERENCES promotion(promotion_id),
    payment_status  VARCHAR(20)   NOT NULL,
    CONSTRAINT ck_invoice_amount CHECK (total_amount >= 0 AND discount_amount >= 0 AND final_amount >= 0)
);

-- 5.2 InvoiceDetail
CREATE TABLE invoice_detail (
    invoice_id INTEGER       NOT NULL REFERENCES invoice(invoice_id),
    line_no    INTEGER       NOT NULL,
    item_type  VARCHAR(20)   NOT NULL,  -- 'Service' hoặc 'Product'
    service_id INTEGER,
    product_id INTEGER,
    quantity   INTEGER       NOT NULL,
    unit_price NUMERIC(18,2) NOT NULL,
    line_total NUMERIC(18,2) NOT NULL,
    CONSTRAINT pk_invoice_detail PRIMARY KEY (invoice_id, line_no),
    CONSTRAINT fk_invoice_detail_service FOREIGN KEY (service_id) REFERENCES service(service_id),
    CONSTRAINT fk_invoice_detail_product FOREIGN KEY (product_id) REFERENCES product(product_id),
    CONSTRAINT ck_invoice_detail_quantity CHECK (quantity > 0),
    CONSTRAINT ck_invoice_detail_price    CHECK (unit_price >= 0 AND line_total >= 0),
    CONSTRAINT ck_invoice_detail_item_type CHECK (item_type IN ('Service','Product'))
);

-- 5.3 Payment
CREATE TABLE payment (
    payment_id     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id     INTEGER       NOT NULL REFERENCES invoice(invoice_id),
    paid_amount    NUMERIC(18,2) NOT NULL,
    payment_method VARCHAR(20)   NOT NULL,
    paid_at        TIMESTAMP(0)  NOT NULL,
    status         VARCHAR(20)   NOT NULL,
    CONSTRAINT ck_payment_amount CHECK (paid_amount >= 0)
);

-- 5.4 Feedback
CREATE TABLE feedback (
    feedback_id    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id     INTEGER      NOT NULL REFERENCES invoice(invoice_id),
    employee_id    INTEGER      REFERENCES employee(employee_id),
    service_id     INTEGER      NOT NULL REFERENCES service(service_id),
    service_rating SMALLINT     NOT NULL,
    staff_rating   SMALLINT,
    comment        VARCHAR(1000),
    created_at     TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ck_feedback_service_rating CHECK (service_rating BETWEEN 1 AND 5),
    CONSTRAINT ck_feedback_staff_rating   CHECK (staff_rating BETWEEN 1 AND 5)
);

-- ============================================
-- 6. MEDICAL RECORDS & PRESCRIPTIONS
-- ============================================

-- 6.1 MedicalRecord
CREATE TABLE medical_record (
    medical_record_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pet_id            INTEGER      NOT NULL REFERENCES pet(pet_id),
    invoice_id        INTEGER      REFERENCES invoice(invoice_id),
    exam_date         TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    diagnosis         VARCHAR(500),
    notes             VARCHAR(500)
);

-- 6.2 MedicalRecordEmployee
CREATE TABLE medical_record_employee (
    medical_record_id INTEGER     NOT NULL REFERENCES medical_record(medical_record_id),
    employee_id       INTEGER     NOT NULL REFERENCES employee(employee_id),
    role_in_exam      VARCHAR(30) NOT NULL,
    CONSTRAINT pk_medical_record_employee PRIMARY KEY (medical_record_id, employee_id)
);

-- 6.3 Prescription
CREATE TABLE prescription (
    prescription_id  INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    medical_record_id INTEGER     NOT NULL REFERENCES medical_record(medical_record_id),
    created_at       TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    notes            VARCHAR(500)
);

-- 6.4 PrescriptionDetail
CREATE TABLE prescription_detail (
    prescription_id   INTEGER      NOT NULL REFERENCES prescription(prescription_id),
    product_id        INTEGER      NOT NULL REFERENCES product(product_id),
    quantity          INTEGER      NOT NULL,
    unit              VARCHAR(20)  NOT NULL,
    usage_instruction VARCHAR(500),
    CONSTRAINT pk_prescription_detail PRIMARY KEY (prescription_id, product_id),
    CONSTRAINT ck_prescription_detail_quantity CHECK (quantity > 0)
);

-- ============================================
-- 7. APPOINTMENT & REMINDERS
-- ============================================

-- 7.1 Appointment
CREATE TABLE appointment (
    appointment_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id      INTEGER      NOT NULL REFERENCES customer(customer_id),
    pet_id           INTEGER      NOT NULL REFERENCES pet(pet_id),
    branch_id        INTEGER      NOT NULL REFERENCES branch(branch_id),
    employee_id      INTEGER      NOT NULL REFERENCES employee(employee_id),
    appointment_time TIMESTAMP(0) NOT NULL,
    status           VARCHAR(20)  NOT NULL,   -- 'Pending','Confirmed','Completed','Cancelled'
    channel          VARCHAR(20)  NOT NULL    -- 'Online','Offline'
);

-- 7.2 AppointmentService
CREATE TABLE appointment_service (
    appointment_id INTEGER NOT NULL REFERENCES appointment(appointment_id),
    service_id     INTEGER NOT NULL REFERENCES service(service_id),
    CONSTRAINT pk_appointment_service PRIMARY KEY (appointment_id, service_id)
);

-- 7.3 Reminder
CREATE TABLE reminder (
    reminder_id    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    appointment_id INTEGER      NOT NULL REFERENCES appointment(appointment_id),
    pet_id         INTEGER      NOT NULL REFERENCES pet(pet_id),
    send_time      TIMESTAMP(0) NOT NULL,
    message        VARCHAR(500) NOT NULL,
    status         VARCHAR(20)  NOT NULL     -- 'Pending','Sent','Failed'
);

-- ============================================
-- 8. EMPLOYEE ASSIGNMENT & TRANSFER
-- ============================================

-- 8.1 EmployeeRoleBranch
CREATE TABLE employee_role_branch (
    employee_id INTEGER     NOT NULL REFERENCES employee(employee_id),
    branch_id   INTEGER     NOT NULL REFERENCES branch(branch_id),
    role_name   VARCHAR(30) NOT NULL,
    CONSTRAINT pk_employee_role_branch PRIMARY KEY (employee_id, branch_id, role_name)
);

-- 8.2 TransferHistory
CREATE TABLE transfer_history (
    transfer_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER     NOT NULL REFERENCES employee(employee_id),
    branch_id   INTEGER     NOT NULL REFERENCES branch(branch_id),
    work_date   DATE        NOT NULL,
    shift       VARCHAR(20) NOT NULL,
    note        VARCHAR(200)
);

-- ============================================
-- 9. INDEXES (PostgreSQL)
-- ============================================

-- 9.1 Appointment - tra cứu theo chi nhánh + thời gian + trạng thái
CREATE INDEX ix_appointment_branch_time_status
ON appointment (branch_id, appointment_time, status)
INCLUDE (customer_id, pet_id, employee_id);

-- 9.2 Invoice - thống kê doanh thu theo chi nhánh + thời gian
CREATE INDEX ix_invoice_branch_created_at
ON invoice (branch_id, created_at)
INCLUDE (final_amount, customer_id, promotion_id);

-- 9.3 InvoiceDetail - thống kê dịch vụ/sản phẩm bán chạy
CREATE INDEX ix_invoice_detail_service
ON invoice_detail (service_id)
INCLUDE (invoice_id, quantity, line_total);

CREATE INDEX ix_invoice_detail_product
ON invoice_detail (product_id)
INCLUDE (invoice_id, quantity, line_total);

-- 9.4 VaccinationHistory - tra lịch sử tiêm cho thú cưng
CREATE INDEX ix_vaccination_history_pet_injection_date
ON vaccination_history (pet_id, injection_date)
INCLUDE (service_id, next_due_date);

-- 9.5 Customer - tìm kiếm theo SĐT / Email
CREATE INDEX ix_customer_phone
ON customer (phone);

CREATE INDEX ix_customer_email
ON customer (email);

-- 9.6 Inventory / WarehouseTransaction (optional nhưng useful)
CREATE INDEX ix_inventory_warehouse_product
ON inventory (warehouse_id, product_id);

CREATE INDEX ix_warehouse_transaction_product_date
ON warehouse_transaction (product_id, transaction_date);
-- 9.7 Pet - tra cứu thú cưng theo khách hàng
CREATE INDEX ix_pet_customer
ON pet (customer_id);

-- 9.8 MedicalRecord - lịch sử khám bệnh theo thú cưng
CREATE INDEX ix_medical_record_pet_exam_date
ON medical_record (pet_id, exam_date);

-- 9.9 Feedback - thống kê đánh giá theo dịch vụ & nhân viên
CREATE INDEX ix_feedback_service
ON feedback (service_id);

CREATE INDEX ix_feedback_employee
ON feedback (employee_id);

-- 9.10 PetVaccinationPackage - gói tiêm đang active theo thú cưng
CREATE INDEX ix_pet_vaccination_package_pet_status
ON pet_vaccination_package (pet_id, status);

-- ============================================
-- TRIGGERS & HELPER FUNCTIONS CHO PETCAREX (PostgreSQL)
-- ============================================

-- 1. HELPER FUNCTION: Cập nhật hạng thành viên dựa trên chi tiêu 12 tháng gần nhất
CREATE OR REPLACE FUNCTION fn_update_membership_tier(p_customer_id INTEGER)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_annual_spend NUMERIC(18,2);
    v_new_tier_id  INTEGER;
BEGIN
    -- Tổng chi tiêu 12 tháng gần nhất (chỉ tính hóa đơn đã thanh toán)
    SELECT COALESCE(SUM(final_amount), 0)
    INTO v_annual_spend
    FROM invoice
    WHERE customer_id = p_customer_id
      AND payment_status = 'Paid'
      AND created_at >= (CURRENT_DATE - INTERVAL '1 year');

    -- Chọn tier có qualify_spend_year <= v_annual_spend, ưu tiên tier cao nhất
    SELECT tier_id
    INTO v_new_tier_id
    FROM membership_tier
    WHERE v_annual_spend >= qualify_spend_year
    ORDER BY qualify_spend_year DESC
    LIMIT 1;

    IF v_new_tier_id IS NOT NULL THEN
        UPDATE customer
        SET tier_id = v_new_tier_id
        WHERE customer_id = p_customer_id;
    END IF;
END;
$$;

-- ============================================
-- 2. TRIGGER: Tính line_total + ràng buộc Service/Product trong invoice_detail
-- ============================================
CREATE OR REPLACE FUNCTION trg_invoice_detail_calc_line_total_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Ràng buộc: item_type = 'Service' => chỉ được có service_id
    IF NEW.item_type = 'Service' THEN
        IF NEW.service_id IS NULL OR NEW.product_id IS NOT NULL THEN
            RAISE EXCEPTION
                'For item_type=Service, service_id must be NOT NULL and product_id must be NULL';
        END IF;

    ELSIF NEW.item_type = 'Product' THEN
        IF NEW.product_id IS NULL OR NEW.service_id IS NOT NULL THEN
            RAISE EXCEPTION
                'For item_type=Product, product_id must be NOT NULL and service_id must be NULL';
        END IF;
    END IF;

    -- Tự động tính line_total = quantity * unit_price
    NEW.line_total := NEW.quantity * NEW.unit_price;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_invoice_detail_calc_line_total
BEFORE INSERT OR UPDATE ON invoice_detail
FOR EACH ROW
EXECUTE FUNCTION trg_invoice_detail_calc_line_total_f();

-- ============================================
-- 3. TRIGGER: Cập nhật total_amount, final_amount cho invoice
-- ============================================
CREATE OR REPLACE FUNCTION trg_invoice_recalc_totals_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_invoice_id INTEGER;
    v_total      NUMERIC(18,2);
BEGIN
    IF TG_OP = 'DELETE' THEN
        v_invoice_id := OLD.invoice_id;
    ELSE
        v_invoice_id := NEW.invoice_id;
    END IF;

    -- Tính lại tổng tiền hóa đơn = SUM(line_total)
    SELECT COALESCE(SUM(line_total), 0)
    INTO v_total
    FROM invoice_detail
    WHERE invoice_id = v_invoice_id;
-- Cập nhật hóa đơn
    UPDATE invoice
    SET total_amount = v_total,
        final_amount = GREATEST(v_total - discount_amount, 0)
    WHERE invoice_id = v_invoice_id;

    RETURN NULL;  -- statement-level cho 1 invoice
END;
$$;

CREATE TRIGGER trg_invoice_recalc_totals
AFTER INSERT OR UPDATE OR DELETE ON invoice_detail
FOR EACH ROW
EXECUTE FUNCTION trg_invoice_recalc_totals_f();

-- ============================================
-- 4. TRIGGER: Cập nhật tồn kho và chặn xuất âm từ warehouse_transaction
-- ============================================
CREATE OR REPLACE FUNCTION trg_warehouse_transaction_update_inventory_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_inventory_id INTEGER;
BEGIN
    IF NEW.transaction_type = 'IMPORT' THEN
        -- Nhập kho: tăng số lượng
        SELECT inventory_id
        INTO v_inventory_id
        FROM inventory
        WHERE warehouse_id = NEW.warehouse_id
          AND product_id   = NEW.product_id
        FOR UPDATE;

        IF NOT FOUND THEN
            INSERT INTO inventory (warehouse_id, product_id, quantity)
            VALUES (NEW.warehouse_id, NEW.product_id, NEW.quantity);
        ELSE
            UPDATE inventory
            SET quantity    = quantity + NEW.quantity,
                update_date = CURRENT_TIMESTAMP
            WHERE inventory_id = v_inventory_id;
        END IF;

    ELSIF NEW.transaction_type = 'EXPORT' THEN
        -- Xuất kho: giảm số lượng, không cho âm
        SELECT inventory_id
        INTO v_inventory_id
        FROM inventory
        WHERE warehouse_id = NEW.warehouse_id
          AND product_id   = NEW.product_id
        FOR UPDATE;

        IF NOT FOUND THEN
            RAISE EXCEPTION
                'No inventory record for warehouse % and product %',
                NEW.warehouse_id, NEW.product_id;
        END IF;

        UPDATE inventory
        SET quantity    = quantity - NEW.quantity,
            update_date = CURRENT_TIMESTAMP
        WHERE inventory_id = v_inventory_id
          AND quantity >= NEW.quantity;

        IF NOT FOUND THEN
            RAISE EXCEPTION
                'Not enough stock for warehouse % and product %',
                NEW.warehouse_id, NEW.product_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_warehouse_transaction_update_inventory
BEFORE INSERT ON warehouse_transaction
FOR EACH ROW
EXECUTE FUNCTION trg_warehouse_transaction_update_inventory_f();

-- ============================================
-- 5. TRIGGER: Cập nhật total_spending, loyalty_points, membership tier khi hóa đơn được Paid
-- ============================================
CREATE OR REPLACE FUNCTION trg_invoice_update_customer_spending_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_points INTEGER;
BEGIN
    -- Chỉ xử lý khi hóa đơn chuyển từ trạng thái khác sang 'Paid'
    IF NEW.payment_status = 'Paid'
AND (OLD.payment_status IS DISTINCT FROM 'Paid') THEN

        -- Tính điểm: 1 điểm = 50,000 VNĐ
        v_points := TRUNC(NEW.final_amount / 50000)::INTEGER;

        UPDATE customer
        SET total_spending = total_spending + NEW.final_amount,
            loyalty_points = loyalty_points + v_points
        WHERE customer_id = NEW.customer_id;

        -- Cập nhật hạng thành viên dựa trên chi tiêu 12 tháng gần nhất
        PERFORM fn_update_membership_tier(NEW.customer_id);
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_invoice_update_customer_spending
AFTER UPDATE ON invoice
FOR EACH ROW
EXECUTE FUNCTION trg_invoice_update_customer_spending_f();

-- ============================================
-- 6. TRIGGER: Chống trùng lịch hẹn (pet/employee bị double slot)
-- ============================================
CREATE OR REPLACE FUNCTION trg_appointment_prevent_conflict_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_conflict_count INTEGER;
BEGIN
    -- Nếu hủy thì không cần check
    IF NEW.status = 'Cancelled' THEN
        RETURN NEW;
    END IF;

    SELECT COUNT(*)
    INTO v_conflict_count
    FROM appointment a
    WHERE a.appointment_time = NEW.appointment_time
      AND a.status <> 'Cancelled'
      AND a.appointment_id <> COALESCE(NEW.appointment_id, -1)
      AND (
           a.employee_id = NEW.employee_id
        OR a.pet_id      = NEW.pet_id
      );

    IF v_conflict_count > 0 THEN
        RAISE EXCEPTION
            'Appointment conflict for pet % or employee % at time %',
            NEW.pet_id, NEW.employee_id, NEW.appointment_time;
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_appointment_prevent_conflict
BEFORE INSERT OR UPDATE ON appointment
FOR EACH ROW
EXECUTE FUNCTION trg_appointment_prevent_conflict_f();

-- ============================================
-- 7. TRIGGER: Tự tạo reminder khi lịch hẹn được Confirmed
-- ============================================
CREATE OR REPLACE FUNCTION trg_appointment_create_reminder_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Tạo reminder khi status chuyển sang Confirmed
    IF NEW.status = 'Confirmed'
       AND (TG_OP = 'INSERT' OR OLD.status IS DISTINCT FROM 'Confirmed') THEN

        -- Xóa các reminder cũ (nếu có) để tránh trùng
        DELETE FROM reminder
        WHERE appointment_id = NEW.appointment_id;

        INSERT INTO reminder (appointment_id, pet_id, send_time, message, status)
        VALUES (
            NEW.appointment_id,
            NEW.pet_id,
            NEW.appointment_time - INTERVAL '1 hour',
            'Nhắc lịch hẹn khám cho thú cưng',
            'Pending'
        );
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_appointment_create_reminder
AFTER INSERT OR UPDATE ON appointment
FOR EACH ROW
EXECUTE FUNCTION trg_appointment_create_reminder_f();

-- ============================================
-- 8. TRIGGER: Feedback phải gắn với dịch vụ có trong hóa đơn
-- ============================================
CREATE OR REPLACE FUNCTION trg_feedback_validate_service_f()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM invoice_detail d
        WHERE d.invoice_id = NEW.invoice_id
          AND d.service_id = NEW.service_id
          AND d.item_type  = 'Service'
    )
    INTO v_exists;

    IF NOT v_exists THEN
        RAISE EXCEPTION
            'Cannot give feedback: invoice % does not contain service %',
            NEW.invoice_id, NEW.service_id;
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_feedback_validate_service
BEFORE INSERT ON feedback
FOR EACH ROW
EXECUTE FUNCTION trg_feedback_validate_service_f();
------------------------------------------------------------------------------------------------------------------------------------------------
-- DROP INDEX ix_appointment_branch_time_status;
-- DROP INDEX ix_invoice_branch_created_at;
-- DROP INDEX ix_invoice_detail_service;
-- DROP INDEX ix_invoice_detail_product;
-- DROP INDEX ix_vaccination_history_pet_injection_date;
-- DROP INDEX ix_customer_phone;
-- DROP INDEX ix_customer_email;
-- DROP INDEX ix_inventory_warehouse_product;
-- DROP INDEX ix_warehouse_transaction_product_date;
